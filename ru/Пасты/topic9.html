<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head>

<strong>Введение</strong><br /><br />Основным мотивом для написания этого текста стало отстутствие на просторах интернета какого-либо внятного учебника по Lua, для чайников и не только, причем на русском языке. Документация на русском есть, а с чего начать - непонятно. Есть хорошая книжка - &quot;Programming in Lua&quot; (причем нужно именно 2-е издание), но ее почему-то даже в электронном виде нигде нет. Мне удалось найти только препринт 1-го издания, и разумеется на английском. После двухгодичной разработки скриптов для хабов на Lua стало ясно, что уж &quot;для чайников&quot; я и сам руководство сделаю. Через некоторое время после осознания этого факта появился черновик, который долгое время оставался совсем убогим и кратким, и вот только сейчас он становится похож на учебник. Отмечу также, что на просторах интернета много различных статей вида &quot;как на Lua сделать что-то эдакое&quot;, но полного подробного учебника пока что не наблюдается. Либо встречаются руководства для продвинутых, которые уже что-то знают и хотят &quot;расшИрить и углУбить&quot; (с) свои знания. Итак, приступим-с...<br /><br />Disclaimer: это учебное описание языка Lua, а не полное руководство. Некоторые аспекты излагаются с некоторой вольностью, чтобы не затмевать суть дела. Да простят меня за это великие умы мира сего.<br /><br />ПС Не мое. Взял на <a href="http://big.vip-zone.su" class="postlink" rel="nofollow" onclick="this.target='_blank';">big.vip-zone.su</a></div>

<div class="postbody"><strong>Обзор Lua</strong><br /><br />Lua -- относительно несложный и в то же время мощный язык, часто применяемый как средство расширения функциональности в многих приложениях, играх, и, что нам в данном случае более интересно, в DC-хабах. В частности, он поддерживается в Verlihub (специальным плагином) и в PtokaX. Как и многие другие скриптовые языки, он позволяет выполнять код без предварительной компиляции (т.е. является интерпретируемым). С одной стороны, это часто ускоряет и упрощает разработку (изменил пару строчек, перезапустил, и всё), с другой стороны, некторые разновидности ошибок отлавливаются только в процессе выполнения данного куска кода. Скажем, вы вызываете функцию, которой не существует, или передаёте ей неверное количество параметров: если эта строчка в силу логики работы программы не выполнится, вы про свою ошибку даже не узнаете <img src="http://forum.qlua.org/images/smilies/icon_e_smile.gif" alt=":)" title="Smile" /> А вот если выполнится, интерпретатор неприлично выругается. Такого почти не бывает в компилируемых языках, в которых код тщательно проверяется на стадии синтаксической проверки, компиляции или линковки.<br /><br />В отличие например от Pascal, Lua не является строго типизированным языком. При инициализации переменных им не нужно указывать тип -- он сам разберется, а объявление переменных фактически не требуется, так как объявлением является присвоение значения. Преобразование из одного типа в другой часто происходит неявно, что упрощает читаемость программы. При этом для любой переменной можно в процессе выполнения узнать ее тип с помощют специального оператора. Более того, тип одной и той же переменной может быть изменен в процессе ее существования при присвоении нового значения (другого типа). Это явление называется динамической типизацией. В Lua (как, например, в javascript), имеется специальное значение nil (аналог null), означающее отсутствие 'содержательных' данных. Как и C/C++, Lua является регистро-чувствительным. Переменная AAA и aaa --- это разные переменные!<br /><br /><strong>Примеры программ в данном тексте и интертрепация</strong><br /><br />Все приводимые ниже примеры вы можете проверить тут: Lua demo -- вставляете код в форму и жмёте кнопочку Run. Ниже образуется вторая форма с выводом вашей программы. Это возможно благодаря тому, что Lua -- интерпретатор и не требует предварительной компиляции кода. Однако для него есть и компилятор luac, который переваривает программу в некий байт-код, который уже быстрее разбирается интерпретатором, что ускоряет загрузку и выполнение программы. Однако скорость выполнения самого скрипта в компилированном и в обычном виде примерно одинакова, в чем я предлагаю убедиться читателю самостоятельно.<br /><br />В заголовке слово &quot;интерпретация&quot; не случайно было написано с опечаткой. Дело в том, что формально отделить компилируемые языки от интерпетируемых - занятие соврешенно бесперспективное, и степень &quot;интерпретируемости&quot; - это скорее какая-то вещественная (дробная) характеристика от 0 до 1. Ведь даже программа на ассемблере (или, давайте уж по полной - &quot;машинный&quot; код) тоже в известном смысле интерпретируется процессором! Так что по сути разница лишь в том, кто интерпретирует код -- железяка или программа (скажем виртуальная машина той же Java). С другой стороны, если зашить интерпретатор Lua в процессор (а почему нет, собственно?), компилятором он от этого не станет <img src="http://forum.qlua.org/images/smilies/icon_e_smile.gif" alt=":)" title="Smile" /><br /><br /><strong>Стандартная библиотека</strong><br /><br />За образец изложения информации о любом языке программирования я беру книгу Бьерна Страуструпа &quot;The C++ Programming Language&quot;, в которой, если я не ошибаюсь, ни разу не упоминается ни одна конкретная операционная система или какая-нибудь библиотека ввода-вывода, которая имеет право иметь различную реализацию (или отсутствовать вовсе!) в различных реализациях языка и в разных ОС. Поэтому я стараюсь минимизировать использование функций, которые могут существенно зависеть от ОС - ведь никто не знает, на каких системах возьмется писать программу кто-нибудь из читателей. Досадное исключение - функция print, которая осуществляет вывод на консоль (а точнее - на стандартный поток вывода stdout), который, к счастью, в том или ином виде присутствует в большинстве ОС.<br /><br />Следует также отметить и такую особенность Lua. Он часто используется как встроенный язык для написания различных расширений, плагинов и тд. В этих случаях у нас вообще, как правило, нет возможности отлаживать нашу программу с помощью print-ов, так как ее вывод зачастую может подавляться. Например, при отладке скриптов для DC-хабов удобно использовать отладочную печать в виде сообщений пользователям хаба (чат хаба используется как консоль вывода). Но это только один из примеров; если читатель сразу возьмется за применение Lua в качестве embedded-языка, пусть подберет себе способ для вывода отладочных сообщений вместо print.<br /><br />По тем же соображениям мы вообще не будем рассматривать такие например операции, как ввод данных с клавиатуры, так как их реализация не имеет ничего общего в различных операционных системах. Файловый же ввод-вывод чуть более стандартизован (и самое главное, бывает нужен в приложениях), поэтому его мы всё-таки коснемся в соответствующей главе. То же самое относится к аргументам командной строки программы.<br /><br /><strong>Элементы и особенности языка</strong><br /><br />Как и в большинстве языков, в Lua есть переменные, операции (арифметические, строковые, и тд), операторы (циклы, ветвление), функции (то есть именованные подпрограммы с параметрами), и библиотека стандартных функций, обеспечивающих взаимодействие программы с ОС и некоторые другие стандартные действия. Оператор цикла for чаще всего используется как конструкция for each и очень применяется для выполнения операций над массивами (таблицами и мета-таблицами), хотя он допускает и классический арифметический вариант с переменной-счётчиком. Циклы while и repeat-until полностью аналогичны большинству языков. Оператор ветвления if допускает секцию elseif, тем самым фактически делает ненужным оператор выбора (case, switch, case of). Как и в C/C++, в Lua нету различий между процедурами и функциями, и те и другие декларируются ключевым словом function, а возвращаемое значение и его тип определяется внутри кода самой функции инструкцией return. И я не сильно ошибусь, если скажу что на этом список ключевых слов языка практически исчерпывается - их действительно очень немного (разумеется, если не учитывать функции стандартной библиотеки, коих имеется превеликое множество.<br /><br />В предыдущем абзаце по сути дела не было упомянуто почти ни одного хитроумного слова, не знакомого человеку, который знает уже какой-нибудь язык программирования. За исключением, пожалуй, одного - загадочного слова мета-таблица. Как мы потом узнаем, в них скрывается вся соль Lua. Пока можно сказать, что это прежде всего, обычные таблицы, но кроме хранения данных они позволяют ещё и перегружать стандартные операции для таблиц, как это делается в С++ с помощью конструкции operator(). Если написанное Вам пока не понятно - не обращайте внимания. На некоторое время мы забудем про всю эту жуть и сначала разберем основы языка, которые, во-первых, элементарны, а во-вторых, очень похожи на базовые конструкции в других языках. Я не случайно ссылаюсь частенько на С/C++, так как многие читатели вполне могут его знать, и им будет проще. Что же касается мета-таблиц, то им будет посвящена целая отдельная глава.<br /><br /><strong>Структура кода</strong><br /><br />В отличие от С++, Pascal и других строгих языков, в Lua исполнение кода программы начинается последовательно, если этот код не является телом функции. Отдельные конструкции языка разделяются пробелом с необязательной точкой с запятой в конце. Я по привычке их ставлю <img src="http://forum.qlua.org/images/smilies/icon_e_smile.gif" alt=":)" title="Smile" /><br /><br />Пример 0<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 -- это наша первая программа на Lua <br />2 print(&quot;Hello from World!&quot;); <br />3&nbsp; <br />4 -- а это функция, которая не вызовется <br />5 function MyFunction() <br />6 print(&quot;Hello from Function!&quot;); <br />7 end<br /></div>При запуске будет выведена только первая строка (Hello from World), так как функцию MyFunction никто не вызовет, и то что написано внутри, не выполнится.<br /><br /><strong>Простейшие примеры</strong><br /><br />Сейчас мы разберем несколько простеньких программ, на которых я постараюсь доказать вам, что Lua -- это очень просто.<br /><br />Пример 1: классический Hello world<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 print(&quot;Hello World!&quot;); <br />2 </div><br />Я думаю, не надо пояснять, что она выведет;) В Lua не требуются всякого рода &quot;точки входа&quot; программы, как в C или Pascal. Исполнение скриптов начинается с первой строки, за исключением тел функций. Они выполняются тогда и только тогда, когда к ним происходит обращение. Следующий пример чуть более содержателен:<br /><br />Пример 2: переменные<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 a = 1; <br />2 print(&quot;Ура, я научился использовать переменные: a = &quot;..a);</div><br />Что же выведет наша программа в примере 2? Между переменной a и строкой используется операция склейки (по-научному - конкатенации) строк -- две точки подряд. Она выведет текст и значение переменной, то есть число 1. Не правда ли, всё просто?<br /><br />Тут же следует сказать о том, что в Lua можно не использовать разделитель ; (точку с запятой) для разделения инструкций. Лично мне ее ставить привычнее, к тому же в С++ их всё равно приходится ставить - так зачем переучиваться? Поэтому я буду их использовать в своих примерах. Кроме того, это вносит дополнительную наглядность.<br /><br />Строковые константы в Lua можно писать как в двойных, так и в одинарных кавычках, как вам удобнее. Если в тексте встречаются кавычки -- можете написать в апострофах, даже не придётся их экранировать символом \, как это приходится делать в C++. Например вот так:<br /><br />Пример 3: строки<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 strApos = &quot;Строка с 'апострофами' внутри&quot;; <br />2 strQuot = 'Строка с &quot;кавычками&quot; внтури';</div><br />А как же быть, если нам надо по каким-то причинам написать строку, в которой (о ужас) есть и кавычки, и апострофы? В этом случае поможет только экранирование:<br /><br />Пример 4: строковый винегрет<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 str = &quot;Строка с \&quot;кавычками\&quot; и 'апострофами' внутри&quot;;</div><br />Если вам нужно осуществить перевод строки, или вставить какой-либо другой служебный символ, пишем так же, как это делается в С/C++.<br /><br />Пример 5: переносы и табуляция в строках<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 print(&quot;А это строка \n с переносами \n строк.\n а вот тут табуляция \t и ещё \n один перенос.&quot;);</div><br />Будет выведено следующее:<br /><br />Вывод примера 5<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 А это строка<br />2&nbsp; с переносами<br />3&nbsp; строк.<br />4&nbsp; а вот тут табуляция&nbsp; &nbsp; и ещё<br />5&nbsp; один перенос.</div><br />На этом мы заканчиваем обзор и переходим к систематическому изложению. Наша программа на ближайшее будущее будет такой: вначале мы обсудим операции и типы данных, потом операторы языка, потом более детально познакомимся с объявлением переменных.</div>

<div class="postbody"><strong>Типы данных: Основы</strong><br /><br />Простые типы<br /><br />Сейчас мы кратко обсудим основные типы данных в Lua, не углубляясь в детали. Это нам потребуется для того, чтобы можно было сочинять более содержательные примеры. Позже мы вернемся к типам данных и переменным и особенностям их объявления.<br /><br />Основными (и наиболее часто используемыми) типами данных в Lua являются числа, строки, логические значения, а также массивы и таблицы из этих значений. Явным образом тип данных никак не указывается - интерпретатор определяет его сам, поэтому многие простые конструкции можно писать чисто интуитивно, и это будет правильно.<br /><br />Типы данных - введение<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 i=1; -- число <br />2 d=3.1415; -- тоже число <br />3 sum=i+d; -- сумма двух чисел <br />4 str=&quot;string&quot;; -- строка</div><br />Больше ничего пока про простые типы я говорить не буду (сознательно) и предлагаю читателью больше пользоваться собственной интуицией при чтении примеров программ. В сложных языках (том же С/С++) это не всегда работает, а вот в Lua - очень даже. Вообще, приятно изучать язык, в котором есть должная степень наглядности кода - он делает именно то, что написано и ничего более, без особых ухищрений со стороны программиста.<br /><br /><strong>Массивы и таблицы</strong><br /><br />Что такое массив, наверное всем понятно. Это набор данных одного и того же типа, занумерованный последовательностью целых чисел (индексами) с &quot;шагом&quot; 1. Обычно индексация делается либо от 0 до N-1, где N - количество элементов массива, либо от 1 до N. И тот и другой подход имеет свои плюсы и минусы; в более низкоуровневых языках вроде С/C++ применяется (и оказывается реально удобнее!) индексация с нуля, а вот в Lua &quot;прижилась&quot; индексация массивов с 1. Как мы потом узнаем, это всё не очень принципиально, и при правильном построении программ об этом вообще не приходится думать.<br /><br />Как объявляются массивы и как с ними работать? Очень просто:<br /><br />Типы данных - массивы<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 -- способ 1 <br />2 array1={}; -- новый пустой массив <br />3 array1&#91;1&#93; = 'first element'; <br />4 array1&#91;2&#93; = 'second element'; <br />5&nbsp; <br />6 -- способ 2 <br />7 array2={&#91;1&#93;='first', &#91;2&#93;='second'}; <br />8&nbsp; <br />9 print(array1&#91;1&#93;, array2&#91;2&#93;);</div><br />Как видите, всё очень наглядно. Размер массива можно узнать следующим образом:<br /><br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">print(#array1);</div><br />Более подробно о массивах, их размерах и других тонкостях мы поговорим в отдельной главе, а пока познакомимся с таблицами. Если читатель знаком, например, с С++ и библиотекой STL, то для него таблица &quot;в первом приближении&quot; - это стандартный контейнер std::map. Для &quot;остальных смертных&quot; придётся сказать, что таблица - это ассоциативный массив, представляющий собой множество пар { (key, value) }, для которого определена операция [] (получение элемента value по ключу key). Немного забегая вперед, скажем что массивы в Lua - это на самом деле тоже таблицы с числовыми значениями ключа key от 1 до размера массива.<br /><br />Вышесказанное показалось вам слишком сложным и непонятным? Ничего страшного, это просто формальное определение интуитивно простых понятий. Сейчас мы рассмотрим пример и всё станет понятно. Например, у нас есть телефонная записная книжка, в которой контактам сопоставлено (для простоты) по одному телефонному номеру. В Lua эту книжку можно было бы задать так:<br /><br />Типы данных - таблицы<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 Phones = { <br />2 &#91;'Вася Пупкин'&#93; = '(495) 504–50–21', <br />3 &#91;'Изольда Кшыштопопвжецкая'&#93; = '2-12-85-06', <br />4 &#91;'МЧС'&#93; = '112', <br />5 }</div><br />В качестве индексов в таблицах можно использовать не только строки и числа, а вообще всё что угодно, в том числе другие таблицы. Обращаться к элементам можно по этим самым индексам. Само собой, при попытке взять элемент, которого не существует, вам вернется значение nil.<br /><br />Для таблиц со строковыми ключами, которые записаны латинскими буквами и не содержат в себе пробелов (то есть по сути являются идентификаторами языка), можно использовать упрощенный синтаксис при обращении к элементам таблицы, делая ее похожей на структуру (или класс). А именно:<br /><br />Таблицы: OOP-style<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 t = {}; <br />2 t.field_x = 10; <br />3 t.field_y = 20; <br />4&nbsp; <br />5 print(t&#91;'field_x'&#93;, t&#91;'field_y'&#93;);</div><br />Здорово, не правда ли? Запись через точку в присвоении выглядит горзадо понятнее, чем в распечатке значений со скобками. Самое главное, у нас появляется возможность двоякой работы с таблицами - как со структурами и как с массивами (ну, разве что с соблюдением более строгих правил для имен полей).<br /><br />На этом мы временно оставим таблицы в стороне - этого нам будет достаточно для понимания некоторых дальнейших примеров.</div>

<div class="postbody"><strong>Операции в Lua</strong><br /><br />Настало время поговорить о самых простых средствах языка - операциях. Как и во всех остальных языках, в Lua имеется более чем джентльменский набор операций - арифметических, логических и строковых. Начнем разумеется с простого -- с арифметики.<br /><br /><strong>Арифметические операции</strong><br /><br />Сколько их, арифметических операций? четыре? Неправильно, шесть: сложение, вычитание, умножение, деление, взятие остатка от деления и возведение в степень. Обозначения их стандартны и используются во многих других языках:<br /><br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">+ - * / % ^</div><br />Приоритеты операций, разумеется, аналогичны обычной арифметике. Но есть и отличия. Например, операция деления целых чисел не является целочисленной (как это происходит в С). Так что выражение<br /><br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">25/2^2</div><br />будет равно 6.25, а не 6, как в языке С/C++. Lua по сути не делает различий между вещественными и целыми числами. Приятно отметить, что он позволяет работать с достаточно большими целыми числами (в текущих реализациях - до 2^46), не переходя к экспоненциальной форме хранения.<br /><br />Кроме арифметических операций, имеется ещё некоторое количество функций математической библиотеки, добавляющие нам разного рода округления, стандартные математические функции типа синусов и косинусов, но их мы обсудим позже.<br /><br /><strong>Логические операции</strong><br /><br />Основные операции &quot;И&quot;, &quot;ИЛИ&quot;, &quot;НЕ&quot; в Lua записываются как and, or, not и полностью аналогичны другим языкам. Пример:<br /><br />Пример 6: Железная логика-1<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 if true and false then <br />2 print(&quot;Вот это ерунда!&quot;); <br />3 end</div><br />Операции сравнения похожи на операции в С/C++. Сравнение здесь пишется двумя знаками равенства ==, а &quot;не равно&quot; -- комбинацией ~= (тильда и знак равенства).<br /><br />Пример 7: Железная логика-2<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 if 1 ~= 2 then <br />2 print(&quot;Не врет железяка&quot;); <br />3 end</div><br />Есть ещё один элегантный случай применения булевых операций, кроме обычных логических выражений. Выглядит он так:<br /><br />Пример 7.5: Использование or<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 number = nil; <br />2 number = number or 0; <br />3 print(number); <br />4 number = 10; <br />5 number = number or 0; <br />6 print(number);</div><br />Первый раз будет напечатано 0, а второй раз -- 10. Таким образом, если один из операндов or равен nil, выражение &quot;x or y&quot; будет равно противоположному операнду. Это удобно для инициализации переменных заведомо корректными значениями (отличными от nil), если заранее значение не известно. Конструкция выглядит гораздо красивее, чем аналогичное сооружение с if.<br /><br /><strong>Строковые операции</strong><br /><br />Со строками можно делать много всего, но операция для работы с ними всего одна - конкатенация (или, по-кухонному, склейка) двух строк. Надо отметить, что для её обозначения пока что не выработалось общемирового стандарта, поэтому в Lua она обозначается двумя точками (к слову, в PHP для этой цели используется точка, в JavaScript - знак плюс). Пример тривиален, но мы его всё-таки напишем:<br /><br />Склейка строк<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">str=&quot;Hello&quot;..&quot;World&quot;;</div><br />Lua допускает склейку строк с числами - в этом случае последние преобразуются в десятичную запись. Пример:<br /><br />Пример 8: Склейка строки и числа<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 str=&quot;Current Lua version is &quot;..5.14;</div><br />Но ни в коем случае не пытайтесь склеивать строку с неинициализированной переменной (или, что то же самое, со значением nil):<br /><br />АнтиПример 9: ошибочная склейка с nil<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 nothing=nil; <br />2 str=&quot;nihil test &quot;..nothing;</div><br />Если переменная nothing не инициализировалась ранее, программа &quot;вылетит&quot; с ошибкой примерно такого содержания: &quot;attempt to concatenate global 'nothing' (a nil value)&quot;. Разумеется, вылетит только во время выполнения, так как заранее никто не знает, будет где-нибудь задано этой переменной значение или нет.<br /><br /><strong>Смешение типов</strong><br /><br />Любопытный читатель наверняка захочет применить какие-нибудь операции к переменным тех типов, к которым &quot;официально&quot; их применять нельзя. И тут его ждет некоторое разочарование - они будут восприняты языком вполне адекватно и естественно. Например:<br /><br />Пример 9.5: Смешение типов<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 num1 = '5' + '7'; -- результат - число <br />2 print(num1); -- 12 <br />3 num2 = '11' * '13' * '7'; -- результат тоже число <br />4 print(num2); -- 1001 <br />5 str = '1234'..'5678'; <br />6 print(str); -- 12345678 <br />7 str = '1234'..'4444'/2; <br />8 print(str); -- 12342222</div><br />В комментариях написаны результаты операций и их типы. Особенно забавна последняя операция, в которой &quot;строковая&quot; константа (по приоритету) делится на число, а потом склеивается с другим числом. Синтаксис это позволяет, но... вообще лучше всегда использовать явное приведение типов, о котором мы расскажем чуть позже.<br /><br /><strong>Операторы языка</strong><br /><br />Сейчас мы перейдем к обсуждению того, без чего не напишешь ни одной серьезной программы. А именно, об операторах языка для управления логикой работы программы. Как и в любом уважающем себя языке, в Lua есть ветвление (if..then..else) и циклы (for, while, repeat). Их мы сейчас и обсудим.<br /><br />Отметим, что в Lua нету так называемых &quot;операторных скобок&quot;, вроде { ... } в С/С++ и begin .. end в Pascal. Поэтому большинство операторов имеют форму ключевое слово ... end (кстати, забегая вперед, скажем что то же самое относится к объявлению функций). Сейчас мы подробно обсудим каждый из операторов, а начнем с самого часто используемого -- условного оператора if.<br /><br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">if..elseif..elseif..else..end</div><br /><br />Синтаксис его таков (поскольку в Lua переносы строк не имеют значения, будем для красоты использовать многострочную запись):<br /><br />Первый, самый простой вариант без else:<br /><br />if: простой вариант<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 if логическое_выражение then <br />2 -- ... <br />3 -- тут идут инструкции, выполняющиеся если выражение истинно <br />4 -- ... <br />5 end</div><br />Вместо многоточий пишите то, что должно быть выполнено, если логическое_выражение может быть (неявно) приведено к логическому true. В Lua значения nil и false воспринимаются как ложь, всё остальное - как истина (даже значение 0). Это немного непривычно для программистов на С и приучает писать сравнения более аккуратно.<br /><br />Второй вариант, с else:<br /><br />if: обычный вариант<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 if логическое_выражение then <br />2 -- тут идут инструкции, выполняющиеся если выражение истинно <br />3 else <br />4 -- а тут -- если оно ложно <br />5 end</div><br />Если условие верно, выполняется первый блок, если нет -- второй. Альтернативных условных блоков может быть много, в этом случае добавляется elseif:<br /><br />if: длинный вариант<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 if выражение1 then <br />2 -- сюда идем, если выражение1 истинно <br />3 elseif выражение2 then <br />4 -- сюда идем, если выражение2 истинно <br />5 elseif выражение3 then <br />6 -- сюда идем, если выражение3 истинно <br />7 ... <br />8 else <br />9 -- сюда идем, если не выполнилось ни одно из предыдущих условий <br />10 end</div><br />TODO: пример на if<br /><br /><strong>Цикл for</strong><br /><br />Цикл имеет два варианта синтаксиса: арифметический и for-each. Разберем сначала первый, для этого хватит пары примеров:<br /><br />for: арифметический<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 for i = 1,10,1 do <br />2 print(&quot;Переменная i внутри цикла равна &quot;..i); <br />3 end</div><br />Тут переменная пробегает значения от 1 до 10 и программа выводит 10 строчек с её значениями. Третье число означает шаг увеличения переменной (если оно равно 1, его можно не писать вообще). Важная особенность: выражения, определяющие начальное, конечное значение и шаг переменной цикла вычисляются один раз при входе в него. Если потребуется выйти &quot;досрочно&quot; - используйте оператор break, о котором будет рассказано далее.<br /><br />Арифметическая форма цикла for используется редко ввиду особенностей языка, а точнее ввиду его области наболее частого применения. Гораздо чаще в Lua применяется второй вариант (если он сейчас будет совсем не понятен, ничего страшного - дальше мы ещё будем очень подробно говорить о таблицах, ключах и индексах). Он обычно называется for-each, так как некоторое действие (в данном случае тело цикла) делается для каждого элемента из некоторого множества (в примере - для каждой записи таблицы).<br /><br />for: модификация for-each<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 -- зададим таблицу из 3 элементов: <br />2 AdminNicks = { <br />3 &quot;root&quot;, <br />4 &quot;admin&quot;, <br />5 &quot;master&quot; <br />6 } <br />7 -- пробежимся по таблице в цикле: <br />8 for k,val in pairs(AdminNicks) do <br />9 print(&quot;К таблице в данном случае можно обращаться так: &quot;..val..&quot;, а можно так: &quot;..AdminNicks&#91;k&#93;..&quot;.&quot;); <br />10 end <br />11 </div><br />Программа выведет три строки с упоминанием в них элементов таблицы. Переменная k пробегает индексы таблицы (т.е. массива), а val -- значения элементов по этим индексам. Здесь мы попутно бегло познакомились с очень полезной конструкцией pairs, которая выдаёт ключ (индекс) таблицы и ее элемент. К этому примеру мы ещё вернемся позже.<br /><br />В качестве более интересного примера для циклов напишем программу, которая выведет все простые числа от 2 до 1000 (делящиеся только на 1 и само себя). Алгоритм самый примитивный, который только может быть (перебор всех делителей).<br /><br />for: поиск простых чисел<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function isPrime(x) -- функция проверки простоты <br />2 for d = 2, x-1, 1 do <br />3 if (x % d) == 0 then return false; end <br />4 end <br />5 return true <br />6 end <br />7&nbsp; <br />8 for i = 2, 1000, 1 do <br />9 if isPrime(i) then print(i); end <br />10 end <br />11 </div><br />Здесь скобки вокруг x % d стоят исключительно для наглядности. Приоритет операции % (остаток от деления, так же как и в С) выше, чем приоритет сравнения.<br /><br /><strong>Цикл while</strong><br /><br />Удобство цикла for проявляется тогда, когда мы знаем, сколько раз нам этот цикл крутить. А если нам нужно какое-то действие выполнять, пока верно некоторое условие, удобнее использовать цикл while. Синтаксис его очень простой:<br /><br />Синтаксис while<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 while логическое_выражение do <br />2 --операции, выполняемые пока выражение истинно <br />3 end</div><br />При входе в цикл значение выражения проверяется на истинность. Если оно ложно, цикл не выполняется ни разу. Если истинно, выполняется первая итерация, и снова проверяется условие. Если оно снова истинно - выполняется вторая итерация, и так далее. Если наше выражение так и останется истинным - цикл будет бесконечным. Наш более содержательный пример - нахождение положительного корня уравнения x^2=2 методом половинного деления на отрезке от 1 до 2. Его значение мы и так знаем: sqrt(2), но мы вычислим его двумя способами и сравним результаты.<br /><br />Пример использования while<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function f(x) <br />2 return x^2 - 2; <br />3 end <br />4&nbsp; <br />5 left=1.0; -- левая граничная точка <br />6 right=2.0; -- правая граничная точка <br />7 m = left; -- начальное приближение корня <br />8&nbsp; <br />9 while math.abs(f(m)) &gt; 0.000000001 do <br />10 if f(m) &gt; 0 then <br />11 right=m; <br />12 else <br />13 left=m; <br />14 end <br />15 m = (left+right)/2; <br />16 end <br />17 print(&quot;Root value: &quot;, m); <br />18 print(&quot;Sqrt(2) : &quot;, math.sqrt(2)); <br />19 print(&quot;Difference: &quot;, math.abs(m-math.sqrt(2))); <br />20 </div><br />Тут, как Вы наверное уже заметили, есть сюрприз в виде неизвестных нам пока функций math.abs и math.sqrt. Знакомые с другими языками разумеется догадались, что это модуль (абсолютное значение) числа и квадратный корень соответственно. Я намеренно включаю в свои примеры некоторые функции из стандартной библиотеки, чтобы читатель постепенно их тоже осваивал по ходу пьесы.<br /><br />Если выполнить программу, мы увидим, что результаты отличаются только в 11-м знаке. Неплохая точность, не правда ли?<br /><br /><strong>Цикл repeat..until</strong><br /><br />Цикл repeat..until отличается от цикла с пред-условием (while) тем, что всегда выполняется хотя бы один раз. Синтаксис его аналогичен while c точностью до зеркального отражения:<br /><br />Синтаксис repeat<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 repeat <br />2 -- тело цикла <br />3 until логическое выражение</div><br />Цикл выполняется до тех пор, пока выражение не станет истинным. Следующий пример печатает первое число, которое больше 2000 и делится на 13:<br /><br />Пример использования repeat<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 x=2000; <br />2 repeat <br />3 x=x+1; <br />4 until (x % 13) == 0; <br />5 print(x);</div><br /><br /><strong>Блок do..end</strong><br /><br />Эта конструкция сама по себе ничего не делает, это просто блок команд, аналогичный {...} в С/C++. Как мы потом узнаем, она влияет на видимость переменных, их глобальность и время жизни. С его помощью удобно выделять логически разные куски кода, если по каким-то причинам их неудобно выносить в отдельные функции. Переменные, обявленные локальными внутри блока, погибают при выходе из его, поэтому целесообразно применять его например в тех случаях, когда мы имеем дело с &quot;большими&quot; (по объему памяти) переменными, и т.д.<br /><br /><strong>Управляющие конструкции в циклах</strong><br /><br />Прервать выполнение цикла досрочно можно с помощью оператора break. Его можно использовать только внутри циклов. Синтаксис его использования таков:<br /><br />Пример использования break<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 i=0; <br />2 while true do -- организуем бесконечный цикл <br />3 print(&quot;Бесконечный цикл&quot;); <br />4 if i &gt; 10000 then <br />5 print(&quot;Всё, хватит&quot;); <br />6 break; <br />7 end <br />8 i=i+1; <br />9 end</div></div>

<div class="postbody"><strong>Переменные: более пристальный взгляд</strong><br /><br />Как правильно объявлять переменные?<br /><br />В Lua можно определять переменные практически где угодно. Вернее, поскольку специальное объявление как таковое не требуется, можно вводить переменную именно тогда, когда уже известно ее значение. Это позволяет избежать ошибок с использованием неинициализированных значений. Стиль, навязываемый скажем, языком Pascal, в котором переменные объявляются в специальной секции, совершенно порочен и кроме ошибок ничего не даёт. Кто-то скажет, что так лучше видно, какие в процедуре есть переменные и какие у них типы, однако же никто не знает, используются они вообще в программе или нет, а уж чему равны - тем более не ясно. Поэтому, объявляйте переменную там и только там, где она вам пригодилась.<br /><br />Глобальные переменные<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 text=&quot;some string&quot;; <br />2 more_text=&quot;second string&quot;..text; <br />3 print(more_text);</div><br />Тут ничего хитрого нет. Объявляется глобальная переменная text, ей задаётся некоторое значение, а потом переменной more_text присваивается склейка строковой константы и значения первой переменной. Вообще, любая переменная в Lua является по умолчанию глобальной. А вот следующий пример уже кому-то может показаться необычным. Во всяком случае, в других языках такие конструкции не работают:<br /><br />Переменные через запятую<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 var_first, var_second = 1, &quot;text&quot;; <br />2 print(var_first); <br />3 print(var_second);</div><br />Здесь будет напечатано сначала 1, а потом text. На первый взгляд не очень понятно, в чем смысл такой конструкции - казалось бы лучше объявить сначала одну переменную, а потом другую. Но этот прием очень часто применяется в более сложных примерах, где используются функции, возвращающие не одно значение, а сразу много. Тогда это становится удобным. А если вам нужно поменять две переменные a и b местами, это можно сделать очень элегантно:<br /><br />Обмен<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">a,b=b,a;</div><br />Не правда ли, красиво? То же самое можно сделать с тремя, четырьмя переменными (например, переставить их по кругу). Разумеется, в таких конструкциях мы должны внимательно следить за порядком переменных, но это уже, как говорится, дело техники. При всём при этом Lua не понимает, например, вот таких вот &quot;извращений в стиле С&quot;:<br /><br />Lua is not a C++<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">var1=var2=var3=var4=1;</div><br /><br /><strong>Область видимости переменных</strong><br /><br />Хороший тон программирования предполагает использовать локальные переменные всюду, где это возможно, и и стараться не использовать глобальных переменных вообще. Поэтому теперь мы будем везде стараться объявлять локальные переменные. Делается это с помощью ключевого слова local.<br /><br />Локальные переменные<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 local var='some string';</div><br />Как это всё работает? продемонстрируем на примере:<br /><br />Локальные переменные<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 var=&quot;ext variable&quot;; <br />2 if 1 ~= 2 then <br />3 local var=&quot;int variable&quot;; <br />4 end <br />5 print(var);</div><br />Как Вы думаете, что напечатает наш пример? Правильно, Вы угадали - он напечатает строку ext variable, потому что переменная внутри оператора if является локальной по отншению к внешней переменной, и значение будет задано у нее, а не переопределено значение внешней переменной. Разумеется, наш пример корректен, поскольку условие верно, и мы попадаем внутрь if-а.<br /><br />Разумеется, если написать вот так:<br /><br />Локальные переменные<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 local var=&quot;ext variable&quot;; <br />2 if 1 ~= 2 then <br />3 var=&quot;int variable&quot;; <br />4 end <br />5 print(var);</div><br />... то переменная у нас тут всего одна и будет изменено именно ее значение, и программа выведет int variable.<br /><br />В общем случае область видимости переменной - это блок некоторого оператора (if, for, while) блок операторов do..end, тело функции или же вся программа (точнее файл). Обладая этим понятием, можно сформулировать общее правило: среди всех переменных с данным названием, встречающихся в коде, в выражении используется ближайшая в данной области видимости (если расстоянием считать глубину вложенности областей).<br /><br />Пожалуй, для полноты картины стоит привести ещё один (не очень хороший, но допустимый) пример кода. К сожалению, он потребует объявления функции, но я надеюсь, интуитивно понятен:<br /><br />Хитроумная видимость и инициализация<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function create_var() <br />2 global_var=&quot;value&quot;; <br />3 end <br />4&nbsp; <br />5 print(global_var); <br />6 create_var(); <br />7 print(global_var);</div><br />Поначалу можно подумать, что будет выведено значение nil два раза, так как &quot;глобальную&quot; переменную global_var никто не инициализирует, а то что делается внутри функции, так и останется в ее пределах. Ан нет: сначала будет напечатано nil, а второй строкой -- слово &quot;value&quot;, потому что внутри функции идёт обращение именно к глобальной сущности. Разумеется, стоит нам написать внутри функции заветное слово local в этом присвоении, как ситуация преобразится радикальным образом, и будет выведено два раза слово nil. Вообще, таких неявных конструкций следует избегать, поскольку они часто порождают ошибки.<br /><br />Осталось заметить, что модификатор local применим так же и к функциям в Lua и влияет на их область видимости (доступности). Это удобно, когда функция заведомо будет использоваться только в рамках данного файла, в котором она описана и не приведет к &quot;засорению&quot; глобального пространства имён.<br /><br /><strong>Типы данных. Динамическая типизация</strong><br /><br />А какие вообще в Lua бывают типы?<br /><br />Наверное многие уже поняли, что в Lua имеют право на жизнь как минимум числа (целые и вещественные, между ними нету разницы), строки и таблицы. На самом деле и это тоже не всё. Фокус в том, что функция в Lua - это тоже тип данных, и с функциями можно обращаться почти так же, как с обычными переменными - присваивать одной функции другую функцию, и многое другое. Но про функции у нас ещё будет отдельный длинный разговор, вернемся на землю к &quot;обычным&quot; переменным и типам. Если читатель ещё не забыл введение, там упоминался ещё один специальный тип nil, озанчающий отсутствие какого-либо объекта. Но и на этом список типов не завершается, поскольку в Lua бывают ещё thread-ы (потоки). Но о них мы поговорим позже.<br /><br />Объявление переменной (точнее, инициализация), как уже говорилось выше, и определяет ее тип в данный момент времени. Почему &quot;в данный момент&quot;, а не вообще? Потому что есть динамическая типизация, о которой речь чуть ниже. Вот несколько примеров определений переменных разных типов:<br /><br />Переменные разных типов<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 local var_int=10; <br />2 local var_float=3.1415926; <br />3 local var_str=&quot;this is a string&quot;; <br />4 local var_table={}; <br />5 local var_func = function() print(&quot;hello from function&quot;); end; <br />6 local var_nil = nil;</div><br />Вот по сути и всё, что в Lua допустимо с точки зрения типов. Последняя запись примера с на самом деле не имеет смысла: любая неинициализированная переменная и так имеет значение . Другое дело что в более сложной программе такое присваивание может вполне себе иметь нетривиальный смысл. Чуть забегая вперед, можно сказать что такая запись ведёт к разрушению данной переменной, если до этого она ссылалась на некоторый объект.<br /><br /><strong>Динамическое определение типа переменной</strong><br /><br />Теперь мы поясним смысл выражения &quot;в данный момент&quot; из предыдущего параграфа. Сейчас мы повторим наш пример, смело заменив в нем имена переменных на какое-нибудь одно (назовем ее просто var):<br /><br />Одна переменная разных типов<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 local var=10; <br />2 print(var, type(var)); -- сейчас это число, будет напечатано '10 number' <br />3 local var=3.1415; <br />4 print(var, type(var)); -- сейчас это тоже число, снова будет напечатано '3.1415 number' <br />5 local var=&quot;text&quot;; <br />6 print(var, type(var)); -- а сейчас это уже строка, будет напечатано 'text string' <br />7 local var={}; <br />8 print(var, type(var)); -- мутируем дальше: var стало таблицей, напечатается 16-ричный адрес и слово 'table' <br />9 local var = function(a,b) return a+b; end; <br />10 print(var(1,2), type(var)); -- дальше - больше: теперь var - это функция, напечатается '3 function' <br />11 local var = nil; <br />12 print(type(var)); -- а теперь переменная погибла, напечатается 'nil nil'</div><br />Проницательный читатель уже давно догадался, что два минуса &quot;--&quot; озанчают строчные комментарии в Lua, а оператор type возвращает тип переменной.</div>

<div class="postbody"><strong>Функции</strong><br /><br />Маленькое лирическое отступление о функциях... Основа читаемости любого кода - это его структурированность. Если написать текст программы &quot;одним куском&quot;, его никто не поймет, а его длина в большинстве случаев увеличится во много раз по сравнению с другими реализациями, а скорость работы возрастёт незначительно. Самый простой способ структурировать программу -- разбить её на подпрограммы, снабдив каждую из них именем. Эти подпрограммы в народе называются процедурами и функциями. Точнее говоря, в разных языках - по-разному, но термин &quot;функция&quot; есть в большинстве языков. Из популярных, пожалуй, только в ассемблере устоялся термин &quot;процедура&quot;, поскольку там функции синтаксически не отличаются от процедур. Обычно под &quot;процедурой&quot; подразумевают подпрограмму, которая делает некоторое действие, но не возвращает никаких значений (например, именно так дела обстоят в Pascal/Delphi), а функция - это подпрограмма, имеющая &quot;результат&quot; в виде некоторого объекта, называемого &quot;возвращаемым значением&quot; (return value) функции. А например в языках С и С++ эта грань, напротив, стерта и там все подпрограммы с точки зрения синтаксиса являются функциями. Так... к чему я это всё? А, ну да. Мне просто хотелось сказать что Lua в этом плане похож на С/С++ и там любая подпрограмма - это функция. А теперь обо всём по порядку.<br /><br /><strong>Простые (классические) примеры функций</strong><br /><br />Синтаксис объявления (описания) функции таков:<br /><br />Описание функции<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function function_name(&lt;arg_list&gt;) <br />2 -- function body <br />3 end</div><br />Описание функции начинается с ключевого слова function, далее в скобках перечисляются аргументы функции (только их имена, никаких типов) которые являются локальными переменными внутри функции. Перед ключевым словом function можно, как и в случае переменных, написать слово local, что повлияет на область видимости самой функции. Аргументами функции обычно является последовательность переменных, разделенных запятой. Почему &quot;обычно&quot;? Потому что есть ещё один интересный и полезный случай, который мы разберем чуть ниже.<br /><br />В отличие, скажем, от С, в Lua нету понятия &quot;протопипа&quot; (заголовка) функции. Она видна везде в своей области видимости, в том числе и выше своего описания.<br /><br />Выход из функции происходит либо по достижению последней инструкци в функции, либо с помощью оператора return. Если return-а нет, наша функция будет возвращать значение nil (то есть на самом деле ничего возвращать не будет).<br /><br />Вот пример содержательной функции, которая осуществляет склейку двух строк с проверкой их типов и пустых значений.<br /><br />Безопасная склейка строк<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function SafeConcat(a, b) <br />2 if not a then return b; end <br />3 if not b then return a; end <br />4 return a..b; <br />5 end <br />6&nbsp; <br />7 print(SafeConcat(&quot;test1&quot;, nil)); <br />8 print(SafeConcat(nil, &quot;test2&quot;)); <br />9 print(SafeConcat(&quot;test3.1&quot;, &quot;test3.2&quot;)); <br />10 print(SafeConcat(4.1, 4.2));</div><br />Этой функцией можно склеивать числа, строки, nil-ы -- всё что угодно, ошибки не произойдет. Потом мы узнаем, как такое можно делать более красиво, но это будет потом.<br /><br /><strong>Функции с переменным числом аргументов</strong><br /><br />Как и в С/C++, в Lua можно задавать функции с переменным числом аргументов. В этом случае они передаются туда как массив с зарезервированным именем arg c индексами от 1 до n, где n=arg.n (буква 'n' -- это тоже на самом деле индекс массива, имеющий строковый тип и значение 'n'. Если это сейчас не очень понятно - ничего страшного, всё встанет на свои места, когда мы разберемся с таблицами, и иожете пока просто это выражение (arg.n) воспринимать как заклинание). Вместо имен параметров функции нужно написать троеточие. Вот пример, который склеивает все свои аргументы (разумеется, кроме nil-ов) в одну строку:<br /><br />Многоточие<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function ConcatMultiple(...) <br />2 local str=&quot;&quot;; <br />3 for i=1,arg.n do <br />4 if arg&#91;i&#93; ~= nil then <br />5 str=str..arg&#91;i&#93;; <br />6 end <br />7 end <br />8 return str; <br />9 end <br />10&nbsp; <br />11 print(ConcatMultiple('a','b',nil,'c','d')); <br />12 </div><br />Когда пойдет разговор о таблицах, мы ещё вспомним этот пример и реализуем эту же функцию иначе. Но вернемся к нашему многоточию. В нашем примере мы заменили им все аргументы функции. Разумеется, это не всегда удобно, поэтому есть возможность использовать и такие конструкции:<br /><br />Параметры и многоточие<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function PrintVarsWithPrefix(prefix, ...) <br />2 print(prefix..&quot;:&quot;); <br />3 for i = 1, arg.n do <br />4 print(&quot; &quot;..arg&#91;i&#93;); <br />5 end <br />6 end <br />7&nbsp; <br />8 local a=1; <br />9 local b=&quot;string&quot;; <br />10 local c=1.5; <br />11&nbsp; <br />12 PrintVarsWithPrefix(&quot;Variables&quot;, a, b, c);</div><br />Подобные описания функций можно применять, когда некоторые параметры имеют для нас особое значение, а некоторые в известном смысле одинаковые и нам не очень важно, кто из них первый кто последний. Наш последний пример выведет вот что:<br /><br />Параметры и многоточие<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 Variables: <br />2&nbsp; 1 <br />3&nbsp; string <br />4&nbsp; 1.5</div><br />Обратите внимание, что нумерация аргументов функции в этом случае остаётся прежней: arg[1] - это первый &quot;динамический&quot; параметр, а не параметр prefix. Поставить многоточие перед именованными аргументами синтаксис Lua, разумеется, запрещает - в этом случае невозможно было бы определить количество динамических и обычных параметров.<br /><br /><strong>Возвращаемые значения функции и оператор return</strong><br /><br />В отличие от многих других языков, в Lua возвращаемых значений у функции может быть много, и при этом не надо их оформлять в виде какой-нибудь специальной структуры. Просто пишите их через запятую, и в том же порядке присваивайте. Например, напишем функцию, которая возвращает сразу и частное, и остаток от деления двух чисел. Она будет очень простая и будет состоять из единственной интересующей нас строчки с return-ом.<br /><br />Множественный return<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function Div(a, b) <br />2 return math.floor(a/b), a % b; <br />3 end <br />4&nbsp; <br />5 local X=57; <br />6 local Y=17; <br />7&nbsp; <br />8 local quot, res = Div(X, Y); <br />9 print(quot, res); <br />10 if quot * Y + res == X then <br />11 print(&quot;All right&quot;); <br />12 end</div><br />Я думаю, что тут происходит - и так понятно. Для полной ясности остаётся лишь сказать, что math.floor возвращает целую часть числа, округленную вниз.<br /><br />Разумеется, если нам нужен только один параметр (скажем, частное), можно написать так:<br /><br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">local quot = Div(X,Y);</div><br />А если нужен только остаток, первый параметр нужно будет тоже куда-то присвоить. Для этого очень часто используют переменную с именем &quot;_&quot;:<br /><br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">local _, res = Div(X,Y);</div><br />Выглядит может быть слегка коряво, но этот приём (и именно такое имя переменной) очень часто применяется в реально существующих проектах на Lua, поэтому изобретать что-то оригинальное в данном случае не хочется. Если Вам нужно добраться до третьего занчения, никто не мешает использовать &quot;мусорную&quot; переменную дважды:<br /><br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">local _,_,var = SomeFunctionReturningThreeParams();</div><br />Проницательный читатель скорее всего уже догадался, что если функция возвращает меньше параметров, чем мы написали в присвоении, последние (недостающие) будут заполнены значением nil. Никаких ошибок вам интерпретатор при этом не выдаст, а молчаливо сделает то, что Вы ему сказали. В нижеследующем примере сначала напечатается &quot;1 2 3&quot;, а потом &quot;5 nil nil&quot;:<br /><br />Множественный return с багом<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function one(a) <br />2 return a; <br />3 end <br />4&nbsp; <br />5 local x,y,z=1,2,3; <br />6 print(x,y,z); <br />7 x,y,z=one(5); <br />8 print(x,y,z);</div><br />Разумеется, количество возвращаемых значений и их типы могут быть непостоянными. Следующий пример может показаться слегка бредовым, но тем не менее любопытным. В нем будет функция, которая возвращает переданный параметр &quot;как есть&quot;, если он строковый, а если передали число - возвращает его же, преобразованное в строковый формат с выравниванием на 10 символов, и второе значение &quot;true&quot; как флаг осущественной конвертации:<br /><br />Return разных типов<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function Convert(var) <br />2 if type(var) == &quot;string&quot; then <br />3 return var; <br />4 end <br />5 if type(var) == &quot;number&quot; then <br />6 return string.format(&quot;%10d&quot;, var), true; <br />7 end <br />8 return &quot;Bug in your code!&quot;; <br />9 end <br />10&nbsp; <br />11 local r1=Convert(2); <br />12 print(r1); <br />13 local r2=Convert(200); <br />14 print(r2); <br />15 local r3=Convert(20000); <br />16 print(r3); <br />17 local r4=Convert(&quot;some string&quot;); <br />18 print(r4); <br />19&nbsp; <br />20 print(Convert());</div><br />Кстати, обратите внимание на последнюю строчку. Там вызывается наша функция Convert без параметров, хотя по идее должна принимать один параметр. Неужели интерпретатор на это ругнется? Конечно же нет! Функция будет вызвана, вот только параметр будет равен nil. В соответствии с тем, что написано в нашей функции, последней строкой будет напечатано &quot;Bug in your code!&quot;.<br /><br /><strong>Прочие особенности вызова функций</strong><br /><br />В Lua допустимы конструкции следующего вида: пусть у вас есть функция, которая принимает (например) два параметра, и вторая функция, которая возвращает два параметра. Можно использовать такую запись:<br /><br />Передача двух параметров сразу<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function exchange(a, b) <br />2 return b, a; <br />3 end <br />4&nbsp; <br />5 function greater(a, b) <br />6 if math.abs(a) &gt; math.abs(b) then return true; end <br />7 return false; <br />8 end <br />9&nbsp; <br />10 local a, b = 1,2; <br />11 print(greater(exchange(b,a))); <br />12 </div><br />Программа напечатает false, поскольку наши переменные будут сначала поменяны местами.<br /><br />Вышеописанный приём можно применять, если &quot;внутренняя&quot; функция (exchange в нашем примере) стоит на последнем месте в списке параметров. Если это не так - из нее будет взят только один параметр. В следующем примере одна из строчек программы выполнится правильно, а вторая сломается на арифметической операции:<br /><br />Передача многих параметров сразу - особенности<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 local a1,a2,a3,a4=1,2,3,4; <br />2&nbsp; <br />3 function sum4(a,b,c,d) <br />4 print(a+b+c+d); <br />5 end <br />6&nbsp; <br />7 function nothing(x,y,z) <br />8 return x,y,z; <br />9 end <br />10&nbsp; <br />11 sum4(a1, nothing(a2,a3,a4)); -- печатает 10 <br />12 sum4(nothing(a1,a2,a3), a4); -- выдаёт ошибку</div><br /><br /><strong>Передача параметров по ссылке и по значению</strong><br /><br />Обычные типы (строки, числа, логические переменные) в Lua передаются в функции по значению (то есть как обычно). Параметр такого типа является локальной переменной внутри функции, его можно менять и при этом значение той переменной, которую мы передавали в функцию, не изменится. Следующий пример это подтверждает:<br /><br />Передача параметров по значению<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function TryToChangeThem(int, float, bool, str) <br />2 int = -int; <br />3 float = float/2; <br />4 bool = not bool; <br />5 str = str..str; <br />6 end <br />7&nbsp; <br />8 local i=1; <br />9 local f=5; <br />10 local b = false; <br />11 local s = &quot;test&quot;; <br />12 TryToChangeThem(i, f, b, s); <br />13 print(i, f, b, s);</div><br />Здесь будут напечатаны именно те значения, которые были изначально присвоены этим переменным. Но есть и другие типы, для которых всё вышесказанное неверно. Среди тех, про которые мы уже что-то знаем, - это таблицы и функции. Есть ещё два типа, про которые пока мне говорить не хочется, чтобы не пугать читателя - с ними мы познакомимся позже.<br /><br />Что же касается таблиц, то приведем простой пример, хотя что такое таблица, я ещё детально не объяснял (рекомендуется вспомнить вот этот пример. По-кухонному в данном примере можно считать, что таблица - это просто некоторая структура данных. В нашем случае это будет пара чисел (скажем, точка на плоскости), а функция по сути описывает некое геометрическое преобразование этой плоскости.<br /><br />Передача параметров по ссылке<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 function Transform(point) <br />2 point.x = point.x / 2; <br />3 point.y = point.y * 2; <br />4 end <br />5&nbsp; <br />6 p = { <br />7 x = 5, <br />8 y = 6 <br />9 }; <br />10&nbsp; <br />11 print(p.x, p.y); <br />12 Transform(p); <br />13 print(p.x, p.y);</div><br />Всё дело в том, что когда мы передаём в функцию таблицу, на самом деле туда передаётся только ее адрес, никакого копирования данных не происходит. То же самое, кстати, происходит при операции присвоения на таблицах.<br /><br />Все эти тонкости надо понимать, чтобы не попортить свои же собственные данные (скажем, &quot;скопировать&quot; одну таблицу в другую и потом начать ее менять, думая что копия-то сохранилась). В других языках выбор типа передачи параметров лежит на пользователе (т.е. программисте), а тут - неявно в зависимости от типа, и за этим вообще говоря надо следить. С той же осторожностью следует обращаться с функциями.<br /><br /><strong>Функция как обычный тип данных</strong><br /><br />Как уже было сказано выше, функция в Lua -- это такой же тип данных, как число или строка. Поэтому допустимы такие конструкции:<br /><br />Переменная-функция<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 local sum = function(x,y) return x+y; end <br />2 print(sum(1,2));</div><br />Здесь пока ничего необчного нет, кроме того что ключевое слово function и имя самой функции (sum) поменялись местами. Теперь никто не мешает &quot;скопировать&quot; эту функцию в другую переменную (то есть на самом деле просто дать ей альтернативное имя, так как никакого физического копирования кода не происходит), например так:<br /><br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">local sum2 = sum;</div><br />После этого можно использовать функцию sum2 наравне с sum - она будет делать в точности то же самое.<br /><br />А вот теперь мы напишем пример посложнее. Он будет осуществлять обычную сортировку массива, который состоит либо из строк, либо из чисел. Причем правило сортировки такое: элемент a1 считается меньше элемента a2, если:<br /><br />a1 - число, а a2 -- строка;<br />a1 и a2 числа, и a1 меньше a2;<br />a1 и a2 строки, и длина a1 меньше длины a2;<br />Вот такая вот изощренная сортировка. Можно было бы написать одну функцию сравнения элементов, рассмотрев в ней все три случая. Но мы поступим иначе - мы напишем три разных функции сравнения для каждого из случаев, и в зависимости от типов будем выбирать одну из трех.<br /><br />Мегасортировка<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 local a={&quot;lua&quot;,100,1,&quot;scripting&quot;,2,45,23,&quot;is very fun!&quot;,52,&quot;super&quot;,56,&quot;a&quot;,4,6,70,&quot;power!&quot;,34,&quot;has&quot;}; <br />2&nbsp; <br />3 function less_num(p,q) <br />4 if a&#91;p&#93; &lt; a&#91;q&#93; then return true; end -- number is always less than string <br />5 return false; <br />6 end <br />7&nbsp; <br />8 function less_str(p,q) <br />9 if string.len(a&#91;p&#93;) &lt; string.len(a&#91;q&#93;) then return true; end <br />10 return false; <br />11 end <br />12&nbsp; <br />13 function less_mixed(p,q) <br />14 if type(a&#91;p&#93;) == type(a&#91;q&#93;) then error(&quot;shit happens&quot;); end <br />15 if type(a&#91;p&#93;) == &quot;number&quot; then return true; end -- number is always less than string <br />16 return false; <br />17 end <br />18&nbsp; <br />19 function getSortFunction(p, q) <br />20 if type(a&#91;p&#93;) == &quot;number&quot; and type(a&#91;q&#93;) == &quot;number&quot; then <br />21 return less_num; <br />22 elseif type(a&#91;p&#93;) == &quot;string&quot; and type(a&#91;q&#93;) == &quot;string&quot; then <br />23 return less_str; <br />24 end <br />25 return less_mixed; <br />26 end <br />27&nbsp; <br />28 function less(p,q) -- общая функция сравнения двух элементов (оператор &quot;меньше&quot;) <br />29 local sort_function = getSortFunction(p, q); -- получаем функцию для сравнения <br />30 if sort_function(p, q) then return true; end <br />31 return false; <br />32 end <br />33&nbsp; <br />34 function getMin(s) <br />35 local l=#a; <br />36 local m = s; <br />37 for j=s+1,l do <br />38 if less(j,m) then <br />39 m=j; <br />40 end <br />41 end <br />42 return m; <br />43 end <br />44&nbsp; <br />45 function megaSort() <br />46 local l = #a; <br />47 for i=1,l do <br />48 local m=getMin(i); <br />49 if m ~= i then <br />50 a&#91;m&#93;,a&#91;i&#93; = a&#91;i&#93;,a&#91;m&#93;; <br />51 end <br />52 end <br />53 end <br />54&nbsp; <br />55 printArray = function() <br />56 local s=&quot;&quot;; <br />57 for i=1,#a do s=s..&quot; &quot;..a&#91;i&#93;; end <br />58 print(s); <br />59 end <br />60&nbsp; <br />61 printArray(); <br />62 megaSort(); <br />63 printArray(); <br />64 </div><br />Когда мы дойдем до изучения таблиц, мы узнаем, что всё то же самое можно было бы сделать гораздо короче и красивее. Мне просто хотелось привести пример относительно большой содержательной программы. На этом мы завершаем знакомство с функциями и переходим к самому интересному - таблицам.</div>

<div class="postbody"><strong>Таблицы и мета-таблицы</strong><br /><br />Начнем с маленького в меру лирического отступления о том, откуда вообще берется такая суета вокруг таблиц и почему они важны. Любой язык программирования (точнее, сама программа) в известном смысле призван моделировать те процессы, которые происходят вокруг нас, систематизировать и перерабатывать какие-то данные, которые у нас имеются, и т.д. Так вот когда данных становится много и они однотипны, образуются последовательности, таблицы, массивы, матрицы, кубы и так далее. Причем очень часто наши данные не имеют каких-либо ярко выраженных &quot;номеров&quot;, которые можно было бы использовать в качестве индексов массива. Или же, номера имеются, но совсем не по порядку или же среди них встречаются вещественные (т.е. не целые) значения. Обычного массива в этом случае не организуешь - он будет либо слишком разреженным, либо неудобным для использования. Каков же выход из этой ситуации? Одно из решений, которое резко упрощает нашу модель - это ассоциативный массив, в котором ключом (индексом) может являться любая сущность, для которой определена операция сравнения (а для хорошей быстрой реализации - ещё и оператор &quot;А меньше Б&quot;). В ассоциативных массивах (то есть std::map-ах в терминологии С++) мы получаем возможность нумеровать элементы любым классом, для которого определены вышеупомянутые операции. Почти то же самое мы имеем и в Lua. Наиболее часто приходится индексировать таблицы числами и строками (а если немного слукавить, то по сути других базовых типов и не бывает в природе).<br /><br />Отметим также и такой немаловажный момент: эффективная реализация таблиц (ассоциативных массивов) позволяет удобно работать с базами данных, поскольку там структура хранения данных именно такова - у большинства таблиц базы есть ключ (или ключи, что не так важно), которому соответствует ровно одна строка (row) таблицы. Чтобы написать на С++ программу, в которой можно было бы легко и удобно оперировать с записями в базе, нам пришлось бы как минимум все таблицы нашей базы реализовать в виде классов. А в Lua этого делать не надо - всё уже сделано до нас! Просто берем и пользуемся. Кстати, библиотека для Lua, которая реализует работу с БД, тоже существует (LuaSQL), и она в разы проще, чем аналогичный API для С++.<br /><br /><strong>Таблицы</strong><br /><br />Если читатель ещё не забыл параграф о таблицах в разделе &quot;Типы данных&quot;, то он наверняка помнит, что новая пустая таблица конструируется с помощью фигурных скобок:<br /><br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">tab={};</div><br />Отметим, что в данном случае в памяти создаётся новый объект и переменной tab присваивается указатель на него. Если мы захотим присвоить одну таблицу другой подобным присвоением - в этом случае мы получим не копию, а два указателя на одно и то же место.<br /><br />Если же мы знаем, чем заполнять таблицу, можно написать и так:<br /><br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">tab={&quot;text&quot;, 1, 2, &quot;other text&quot;, 3};</div><br />В этом случае элементы будут автоматически пронумерованы числами, начиная с 1. Давайте в этом наглядно убедимся с помощью простой программы:<br /><br />Автонумерация<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 tab={&quot;text&quot;, 1, 2, &quot;other text&quot;, 3}; <br />2 for i,v in pairs(tab) do <br />3 print(i, v); <br />4 end</div><br />Выполните её, и убедитесь, что порядок элементов сохранился, а индексы будут от 1 до 5. Фактически, тут мы получили обычный массив. Для полной ясности надо разобрать подобнее оператор for и конструкцию pairs, чему посвящен следующий параграф, а пока что посмотрим, какие ещё есть способы инициализации таблиц.<br /><br /><strong>Особенности национальной индексации</strong><br /><br />Индексы можно указывать явно, в данном примере результат будет в точности такой же как и в предыдущей программе:<br /><br />Явная нумерация<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 tab={ <br />2 &#91;1&#93;=&quot;text&quot;, <br />3 &#91;2&#93;=1, <br />4 &#91;3&#93;=2, <br />5 &#91;4&#93;=&quot;other text&quot;, <br />6 &#91;5&#93;=3 <br />7 } <br />8 </div><br />А вот пример с индексами разных типов:<br /><br />Смешанная индексация<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 tab={ <br />2 &#91;1&#93;=&quot;text&quot;, <br />3 &#91;2&#93;=1, <br />4 &#91;&quot;key&quot;&#93;=&quot;value&quot; <br />5 }; <br />6 for i, v in pairs(tab) do <br />7 print(&quot;Key is: &quot;, i, &quot;Value is: &quot;, v, type(i)); <br />8 end</div><br />Однако лучше не злоупотреблять смешанной индексацией без необходимости, поскольку это может привести к ошибкам. Засада заключается в том, что Lua различает строковые и числовые индексы, и поэтому t[1] не равно t[&quot;1&quot;]. Вот пример:<br /><br />Засада с типами<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 tab_auto={&quot;value&quot;}; <br />2 print(tab_auto&#91;1&#93;, tab_auto&#91;&quot;1&quot;&#93;); <br />3&nbsp; <br />4 tab_man={&#91;1&#93;=&quot;value&quot;}; <br />5 print(tab_man&#91;1&#93;, tab_man&#91;&quot;1&quot;&#93;); <br />6&nbsp; <br />7 tab_str={&#91;&quot;1&quot;&#93;=&quot;value&quot;}; <br />8 print(tab_str&#91;1&#93;, tab_str&#91;&quot;1&quot;&#93;);</div><br />Программа печатает вот что:<br /><br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">value&nbsp; &nbsp;nil<br />value&nbsp; &nbsp;nil<br />nil&nbsp; &nbsp;value</div><br />Таким образом, правило простое: какой индекс мы выбрали - по такому и следует обращаться, в случае индексов таблиц автоматической конвертации типов нет.<br /><br />Тут стоит сказать ещё про одну засаду. Следующий пример относится скорее к категории антипримеров, то есть &quot;как не надо делать&quot;. А именно, не стоит использовать одновременно явную и неявную индексацию массивов.<br /><br />Ошибка инициализации таблицы<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 tab={ <br />2 &#91;1&#93;=&quot;number one...&quot;, <br />3 &#91;2&#93;=&quot;number two...&quot;, <br />4 &quot;number three...&quot;, <br />5 &quot;...etc&quot; <br />6 } <br />7 for i, v in pairs(tab) do <br />8 print(&quot;Key: &quot;, i, &quot;Val: &quot;, v, &quot;Type: &quot;, type(i)); <br />9 end</div><br />В этой программе первые два элемента просто погибнут, так как они будут замещены автоматически пронумерованными 3-м и 4-м элементом. В итоге таблица будет из 2 строк, а не из четырех.<br /><br /><strong>Таблицы как структуры</strong><br /><br />Есть ещё один замечательный способ задания индексов таблиц, который наверняка понравится любителям ООП. Можно использовать такую запись:<br /><br />Структуры<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 complex = { <br />2 re=1, <br />3 im=2 <br />4 }; <br />5 print(complex.re, complex.im); <br />6 print(complex&#91;&quot;re&quot;&#93;, complex&#91;&quot;im&quot;&#93;); <br />7 </div><br />В двух строках будет выведено одно и то же, так как запись table.key и table[&quot;key&quot;] означает одно и то же. Согласитесь, что первая конструкция намного симпатичнее второй.<br /><br /><strong>for, pairs и ipairs<br /></strong><br />Для перечисления элементов таблиц нам уже не годится арифметический цикл for, так как вместо номеров (индексов) могут быть и строки, и таблицы, и числа, и функции. Для таких случаев есть оператор in, который умеет перечислять все элементы массива или таблицы в некотором порядке. А в каком именно порядке - это может зависеть от реализации нашего интерпретатора, стандарта на этот счёт не существует. Можно только лишь гарантировать, что он переберёт все элементы. Множество элементов, по которому мы будем бегать, можно получить с помощью оператора pairs. Он будет выдавать нам по очереди все пары [индекс, значение] нашей таблицы (а точнее говоря - [ключ, значение], так как в случае строковых ключей таблицы слово &quot;индекс&quot; не очень уместно).<br /><br />Распечатка всех значений таблицы<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 tab={&quot;it&quot;, &quot;is&quot;, &quot;a&quot;, &quot;Table&quot;}; <br />2 for i, v in pairs(tab) do <br />3 print(&quot;Key is: &quot;, i, &quot;Value is: &quot;, v); <br />4 end</div><br />Распечатка всех значений таблицы (вывод)<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 Key is: 1Value is: it <br />2 Key is: 2Value is: is <br />3 Key is: 3Value is: a <br />4 Key is: 4Value is: Table</div><br />Я думаю, теперь читателю стали полностью понятны примеры, которые приводились выше в предыдущих параграфах.<br /><br />Если мы захотим перебрать только числовые индексы таблиц, нам поможет конструкция ipairs. Работает она совершенно аналогично:<br /><br />Распечатка значений таблицы с числовыми индексами<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 tab={ <br />2 &#91;1&#93;=&quot;text&quot;, <br />3 &#91;&quot;key&quot;&#93;=&quot;value&quot;, <br />4 &#91;2&#93;=&quot;other text&quot;, <br />5 &#91;3&#93;=3 <br />6 } <br />7 print(&quot;Number Pairs&quot;); <br />8 for i, v in ipairs(tab) do <br />9 print(&quot;Key is: &quot;, i, &quot;Value is &quot;, v); <br />10 end <br />11 print(&quot;All Pairs&quot;); <br />12 for i, v in pairs(tab) do <br />13 print(&quot;Key is: &quot;, i, &quot;Value is &quot;, v); <br />14 end</div><br /><br /><strong>Размер таблицы, количество элементов, обход всех элементов</strong><br /><br />Вообще говоря, понятие &quot;размера&quot; в Lua применимо только к массивам, то есть к таблицам с числовыми индексами. Размером массива tab называется индекс i максимального элемента, такого что tab[i] ~= nil, а tab[i+1] = nil (и при этом все элементы с меньшими номерами также не нулевые). Одним словом, размер - это длина непрерывной последовательности непустых индексов от начала масива. Размер можно получить с помощью операции &quot;#&quot;:<br /><br />Получение размера таблицы<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 tab={&quot;array&quot;, &quot;length&quot;, &quot;sample&quot;}; <br />2 local size=#tab; <br />3 print(size);</div><br />Что будет напечатано? Конечно же, число 3. А вот пример похитрее:<br /><br />Получение размера таблицы с дыркой<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 tab={&#91;1&#93;=&quot;array&quot;, &#91;2&#93;=&quot;length&quot;, &#91;3&#93;=&quot;sample&quot;, &#91;5&#93;=&quot;hole between indexes&quot;}; <br />2 print(#tab);</div><br />В соответствии с определением длины, тут тоже будет напечатано число 3.<br /><br />Для произвольной таблицы длина вообще не определена. Узнать количество элементов в ней можно, лишь обойдя ее полностью по уже изученной схеме циклом for.<br /><br /><strong>Стандартная библиотека table</strong><br /><br />Для удобной работы с массивами в Lua есть стандартная библиотека table. Там есть весьма часто используемые функции, например добавление и удаление элементов, сортировка и прочее. Следующий пример считывает построчно файл программы (то есть самой себя) и складывает в массив, а потом печатает ее:<br /><br />Нечестный способ распечатать собственный текст<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 local selftext={}; <br />2 for line in io.lines(arg&#91;0&#93;) do <br />3 table.insert(selftext, line); <br />4 end <br />5 for _,line in pairs(selftext) do <br />6 print(line); <br />7 end</div><br />Функция table.insert имеет два обязательных параметра (таблицу и новый элемент), и необязательный параметр position, указывающий куда этот элемент вставлять. Если он не указан, добавление происходит в конец таблицы. Вот та же самая программа, печатающая себя вверх ногами:<br /><br />Вверх дном<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 local selftext={}; <br />2 for line in io.lines(arg&#91;0&#93;) do <br />3 table.insert(selftext, 1, line); <br />4 end <br />5 for _,line in pairs(selftext) do <br />6 print(line); <br />7 end</div><br />Помните, в самом начале у нас была программа, печатающая простые числа? Вот ее более быстрая реализация с помощью таблиц:<br /><br />Ускоренные простые числа<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 local primes={2,3}; <br />2 local n=10000; <br />3&nbsp; <br />4 function isPrime(x) <br />5 for _,p in pairs(primes) do <br />6 if x%p == 0 then return false; end <br />7 if p &gt; x/2 then break; end <br />8 end <br />9 return true; <br />10 end <br />11&nbsp; <br />12 for i = 5,n,2 do <br />13 if isPrime(i) then table.insert(primes,i); end <br />14 end <br />15&nbsp; <br />16 for i,v in pairs(primes) do <br />17 print(v); <br />18 end <br />19 </div><br />То, что оно работает быстрее, предлагается проверить читателю. А ещё ему предлагается написать аналогичный код, скажем, на С++ и посмотреть, на сколько ему удастся обогнать Lua. Таблицы реализованы в Lua очень эффективно, и проигрывают С-шным реализациям не так уж сильно (иногда &quot;всего&quot; в 2-3 раза, что для интерпретируемого языка, согласитесь, очень нехило). У других скриптовых языков, например у Python в среднем этот коэффициент существенно выше, хотя его спасает очень богатая стандартная библиотека, которая само собой реализована на С и потому &quot;кишки&quot; работают быстро.<br /><br />Ещё одна операция, которая часто используется в прикладных программах, - это сортировка. Lua умеет сортировать таблицы, если ему объяснить, как сравнивать два элемента. Объяснение делается с помощью функции сравнения, которую надо передать стандартной библиотеке. Если ее не указать, он будет пытаться сравнивать элементы стандартным оператором &lt;, и в простых случаях оно даже сработает. Вот примеры:<br /><br />Сортировка массива<br /><div class="codetitle"><b>Код:</b></div><div class="codecontent">1 local array_int={3,45,6,234,653,2,51,43,32}; <br />2 table.sort(array_int); <br />3 print(table.concat(array_int, ', ')); <br />4 local array_string={&quot;lua&quot;, &quot;is&quot;, &quot;a&quot;, &quot;great&quot;, &quot;language&quot;}; <br />5 table.sort(array_string); <br />6 print(table.concat(array_string, ', '));</div></div>

<div class="postbody">Собственно, вот второе издание, на английском конечно  <img src="http://forum.qlua.org/images/smilies/icon_e_smile.gif" alt=":)" title="Smile" /> <br />Programming in Lua, Second Edition<br /><br />Год: 2006<br />Автор: Roberto Ierusalimschy<br />Жанр: Учебное пособие<br />Издательство: Lua.org<br />ISBN: 85-903798-2-5<br />Язык: Английский<br />Формат: PDF<br />Качество: Изначально компьютерное (eBook)<br />Количество страниц: 329<br /><br /><!-- m --><a class="postlink" href="http://rutracker.org/forum/viewtopic.php?t=3682281" rel="nofollow" onclick="this.target='_blank';">http://rutracker.org/forum/viewtopic.php?t=3682281</a><!-- m --></div>

<div class="postbody"><strong>patch_ua</strong><div class="quotetitle"><b>Цитата:</b></div><div class="quotecontent">Disclaimer: это учебное описание языка Lua, а не полное руководство. Некоторые аспекты излагаются с некоторой вольностью, чтобы не затмевать суть дела. Да простят меня за это великие умы мира сего.<br /><br />ПС Не мое. Взял на big.vip-zone.su</div> а можно файл то? <br />Я войти/скачать не могу - нужен Лог+Пасс</div>

<div class="postbody"><br />_________________<br /><em>&quot;На каждое действие есть равная ему противодействующая критика.&quot;</em> <strong>Постулат Харриссона</strong></div>
<div class="postbody"><div class="quotetitle">Indomito писал(а):</div><div class="quotecontent"><strong>patch_ua</strong><div class="quotetitle"><b>Цитата:</b></div><div class="quotecontent">Disclaimer: это учебное описание языка Lua, а не полное руководство. Некоторые аспекты излагаются с некоторой вольностью, чтобы не затмевать суть дела. Да простят меня за это великие умы мира сего.<br /><br />ПС Не мое. Взял на big.vip-zone.su</div> а можно файл то? <br />Я войти/скачать не могу - нужен Лог+Пасс</div><br />уже нету файла(</div>